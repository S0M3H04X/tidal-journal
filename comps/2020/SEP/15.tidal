-- Week4: RANDOMNESS

--
resetCycles

d4
    $ repeatCycles 8
    $ jux rev
    $ n "0*64"
    # s "cpu"
    # squiz (rand + sine*1.2)
    # speed (rand + 2)
    # vowel (wrandcat [
        ("a e*3 o", 0.6),
        ("e o i", 0.5),
        ("i*4 u", 0.2)
        ])
    # gain (fast 2 $ range 0.5 0.9 $ sine*1.02)
    # orbit 2


hush

-- irand
d1
    $ repeatCycles 4
    $ n (scale "ionian" $ struct "t(5,8)" $ (irand 8) + 24)
    # s "rash"

-- [|]
-- ?
d1
    $ n "0 [0|1*3|2*8|3 4 5] 2 3"
    # s "cpu"

d1
    $ s "bd*8?0.5"
-- default being 0.5 of chances of playing the sample

hush

-- scramble
d1
    $ scramble 4
    $ n "0 1 2 3 4 5 6 7" -- scaramble makes the sequence into 4 pairs "[0 1] [2 3] [4 5] [6 7]" and picks each randomly
    # s "arpy"

d1
    $ shuffle 4
    $ n "0 1 2 3 4 5 6 7"
    # s "arpy"


-- choose
d1 $ s (segment 4 $ choose ["bd", "arpy", "kick"])

d2 $ s (struct "t(5,8,<0 2>)" $ choose ["bd", "arpy", "kick"])

hush


:t wchoose

-- wchoose
d1 $ s "bd*8" # squiz (wchoose [(1, 2), (5, 0.1), (10, 0.5)])


-- pan and speed are randomized in the same way
d1 $ s "bd*8" # pan rand # speed (range 1 4 rand)

-- offset pan and speed by 1 cycle
d1 $ s "bd*8" # pan rand # speed (1 <~ (range 1 4 rand))

-- offset pan and speed by faster the speed
d1 $ s "bd*8" # pan rand # speed (fast 1.01 $ range 1 4 rand)



hush



-- randcat
d1
    $ vowel (cat ["a e*2 i o", "e o u", "o*8"])
    # s (randcat ["kick snare:4 [~ kick] snare:5",
                "kick snare:4 . hc(5,8)",
                "snare:9(9,16)"])
-- wrandcat
d3
    $ s (wrandcat [
        ("bd sn:4(3,8)", 1),
        ("arpy clap", 0.5),
        ("cpu(5,8)", 0.25)
        ])

d1
    $ stripe 2
    $ n "0 4*2 ~ 4 2 4 5"
    # s "cpu2"
    # squiz 2

d2
    $ s "clap:4"

hush

d1
    $ degradeBy 0.6
    $ s "bd*8"
